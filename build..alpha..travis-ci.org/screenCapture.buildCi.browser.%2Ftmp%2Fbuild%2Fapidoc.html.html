<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/Medium/kew">kew (v0.7.0)</a>
</h1>
<h4>a lightweight promise library for node</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew">module kew</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise">
            function <span class="apidocSignatureSpan">kew.</span>Promise
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.all">
            function <span class="apidocSignatureSpan">kew.</span>all
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.allSettled">
            function <span class="apidocSignatureSpan">kew.</span>allSettled
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.bindPromise">
            function <span class="apidocSignatureSpan">kew.</span>bindPromise
            <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.defer">
            function <span class="apidocSignatureSpan">kew.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.delay">
            function <span class="apidocSignatureSpan">kew.</span>delay
            <span class="apidocSignatureSpan">(delayMsOrVal, opt_delayMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.fcall">
            function <span class="apidocSignatureSpan">kew.</span>fcall
            <span class="apidocSignatureSpan">(fn, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.getNextTickFunction">
            function <span class="apidocSignatureSpan">kew.</span>getNextTickFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.isPromise">
            function <span class="apidocSignatureSpan">kew.</span>isPromise
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.isPromiseLike">
            function <span class="apidocSignatureSpan">kew.</span>isPromiseLike
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.ncall">
            function <span class="apidocSignatureSpan">kew.</span>ncall
            <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.nfcall">
            function <span class="apidocSignatureSpan">kew.</span>nfcall
            <span class="apidocSignatureSpan">(fn, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.reject">
            function <span class="apidocSignatureSpan">kew.</span>reject
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.resolve">
            function <span class="apidocSignatureSpan">kew.</span>resolve
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.setNextTickFunction">
            function <span class="apidocSignatureSpan">kew.</span>setNextTickFunction
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.spread">
            function <span class="apidocSignatureSpan">kew.</span>spread
            <span class="apidocSignatureSpan">(array, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kew.</span>Promise.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kew.</span>stats</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise">module kew.Promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.Promise">
            function <span class="apidocSignatureSpan">kew.</span>Promise
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype">module kew.Promise.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._chainPromise">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_chainPromise
            <span class="apidocSignatureSpan">(promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._end">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._handleError">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_handleError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._nextTick">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_nextTick
            <span class="apidocSignatureSpan">(fn, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._useContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_useContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withError">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withError
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withInput">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withInput
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.clearContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>clearContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.delay">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>delay
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.done">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>done
            <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.end">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fail">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fail
            <span class="apidocSignatureSpan">(onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.failBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>failBound
            <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fin">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fin
            <span class="apidocSignatureSpan">(onComplete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.getContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.makeNodeResolver">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>makeNodeResolver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.reject">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>reject
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.resolve">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>resolve
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.setContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>setContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spread">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spread
            <span class="apidocSignatureSpan">(onSuccess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spreadBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spreadBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.then">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>then
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.thenBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>thenBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.timeout">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>timeout
            <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew" id="apidoc.module.kew">module kew</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise" id="apidoc.element.kew.Promise">
        function <span class="apidocSignatureSpan">kew.</span>Promise
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(onSuccess, onFail) {
  this.promise = this
  this._isPromise = true
  this._successFn = onSuccess
  this._failFn = onFail
  this._scope = this
  this._boundArgs = null
  this._hasContext = false
  this._nextContext = undefined
  this._currentContext = undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.all" id="apidoc.element.kew.all">
        function <span class="apidocSignatureSpan">kew.</span>all
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(promises) {
  if (arguments.length != 1 || !Array.isArray(promises)) {
    promises = Array.prototype.slice.call(arguments, 0)
  }
  return allInternal(promises)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function reject(e) {
 var promise = new Promise()
 promise.reject(e)
 return promise
}

/**
* Replace an element in an array with a new value. Used by .<span class="apidocCodeKeywordSpan">all</span>() to
* call from .then()
*
* @param {!Array} arr
* @param {number} idx
* @param {*} val
* @return {*} the val that's being injected into the array
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.allSettled" id="apidoc.element.kew.allSettled">
        function <span class="apidocSignatureSpan">kew.</span>allSettled
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allSettled(promises) {
  if (!Array.isArray(promises)) {
    throw Error('The input to "allSettled()" should be an array of Promise or values')
  }
  if (!promises.length) return resolve([])

  var outputs = []
  var promise = new Promise()
  var counter = promises.length

  for (var i = 0; i &lt; promises.length; i += 1) {
    if (!promises[i] || !isPromiseLike(promises[i])) {
      replaceElFulfilled(outputs, i, promises[i])
      if ((--counter) === 0) promise.resolve(outputs)
    } else {
      promises[i]
        .then(replaceElFulfilled.bind(null, outputs, i), replaceElRejected.bind(null, outputs, i))
        .then(function () {
          if ((--counter) === 0) promise.resolve(outputs)
        })
    }
  }

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function replaceEl(arr, idx, val) {
  arr[idx] = val
  return val
}

/**
 * Replace an element in an array as it is resolved with its value.
 * Used by .<span class="apidocCodeKeywordSpan">allSettled</span>().
 *
 * @param {!Array} arr
 * @param {number} idx
 * @param {*} value The value from a resolved promise.
 * @return {*} the data that's being passed in
 */
function replaceElFulfilled(arr, idx, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.bindPromise" id="apidoc.element.kew.bindPromise">
        function <span class="apidocSignatureSpan">kew.</span>bindPromise
        <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bindPromise(fn, scope, var_args) {
  var rootArgs = Array.prototype.slice.call(arguments, 2)
  return function onBoundPromise(var_args) {
    var defer = new Promise()
    try {
      fn.apply(scope, rootArgs.concat(Array.prototype.slice.call(arguments, 0), defer.makeNodeResolver()))
    } catch (e) {
      defer.reject(e)
    }
    return defer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// test binding a callback function with a promise
exports.testBindPromise = function (test) {
  var adder = function (a, b, callback) {
    callback(null, a + b)
  }

  var boundAdder = Q.<span class="apidocCodeKeywordSpan">bindPromise</span>(adder, null, 2)
  boundAdder(3)
    .then(function (val) {
      test.equal(val, 5, "Val should be 2 + 3")
      test.done()
    })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.defer" id="apidoc.element.kew.defer">
        function <span class="apidocSignatureSpan">kew.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer() {
  return new Promise()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var failPromise = Q.reject(err)
```

In addition, you can create deferreds which can be used if you need to create a promise but resolve it later:

```javascript
// create the deferreds
var successDefer = Q.<span class="apidocCodeKeywordSpan">defer</span>()
var failDefer = Q.defer()

// resolve or reject the defers in 1 second
setTimeout(function () {
  successDefer.resolve("ok")
  failDefer.reject(new Error("this failed"))
}, 1000)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.delay" id="apidoc.element.kew.delay">
        function <span class="apidocSignatureSpan">kew.</span>delay
        <span class="apidocSignatureSpan">(delayMsOrVal, opt_delayMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delay(delayMsOrVal, opt_delayMs) {
  var returnVal = undefined
  var delayMs = delayMsOrVal
  if (typeof opt_delayMs != 'undefined') {
    delayMs = opt_delayMs
    returnVal = delayMsOrVal
  }

  if (typeof delayMs != 'number') {
    throw new Error('Bad delay value ' + delayMs)
  }

  var defer = new Promise()
  setTimeout(function onDelay() {
    defer.resolve(returnVal)
  }, delayMs)
  return defer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Q.all(promises)
.fail(function (e) {
  console.log("Failed retrieving a url", e)
})
```

### `.<span class="apidocCodeKeywordSpan">delay</span>()` for future promises

If you need a little bit of delay (such as retrying a method call to a service that is "eventually consistent") before
 doing something else, ``Q.delay()`` is your friend:

```javascript
getUrlContent(url1)
.fail(function () {
// Retry again after 200 milisseconds
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.fcall" id="apidoc.element.kew.fcall">
        function <span class="apidocSignatureSpan">kew.</span>fcall
        <span class="apidocSignatureSpan">(fn, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fcall(fn, var_args) {
  var rootArgs = Array.prototype.slice.call(arguments, 1)
  var defer = new Promise()
  nextTick(nextTickCallback.bind(null, defer, fn, undefined, rootArgs))
  return defer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
Q.delay(obj, 20).then(function (result) {
  console.log(result) // logs `obj` after 20ms
})
```

### `.<span class="apidocCodeKeywordSpan">fcall</span>()` for delaying a function invocation until the next tick:
```javascript
// Assume someFn() is a synchronous 2 argument function you want to delay.
Q.fcall(someFn, arg1, arg2)
  .then(function (result) {
    console.log('someFn(' + arg1 + ', ' + arg2 + ') = ' + result)
  })
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.getNextTickFunction" id="apidoc.element.kew.getNextTickFunction">
        function <span class="apidocSignatureSpan">kew.</span>getNextTickFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNextTickFunction() {
  return nextTick
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var Q = require('../kew')

function synchronous (callback) {
callback()
}

var asynchronous = Q.<span class="apidocCodeKeywordSpan">getNextTickFunction</span>()

exports.testAsynchronousSynchronous = function (test) {
Q.setNextTickFunction(synchronous)

var number = 5

Q.resolve(true).then(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.isPromise" id="apidoc.element.kew.isPromise">
        function <span class="apidocSignatureSpan">kew.</span>isPromise
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromise(obj) {
  return !!obj._isPromise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Q = require('../kew')

exports.testThen = function (test) {
var detectedScope = null
Q.resolve(true).then(function () {
  detectedScope = this
}).then(function () {
  test.ok(Q.<span class="apidocCodeKeywordSpan">isPromise</span>(detectedScope), 'then() should be called in context of promise
')
  test.done()
})
}

exports.testFail = function (test) {
var detectedScope = null
Q.reject(new Error()).fail(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.isPromiseLike" id="apidoc.element.kew.isPromiseLike">
        function <span class="apidocSignatureSpan">kew.</span>isPromiseLike
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromiseLike(obj) {
  return (typeof obj === 'object' || typeof obj === 'function') &amp;&amp;
    typeof obj.then === 'function'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      fn('like a promise, brah!')
    }
  }
  var kewLikeFunction = function() {}
  kewLikeFunction.then = function(fn) {
    fn('like a promise, brah!')
  }
  test.equal(Q.<span class="apidocCodeKeywordSpan">isPromiseLike</span>(kewPromise), true, 'A Kew promise is promise-like&amp;#
x27;)
  test.equal(Q.isPromiseLike(qPromise), true, 'A Q promise is promise-like')
  test.equal(Q.isPromiseLike(kewLikeObject), true, 'A pretend promise is a promise-like')
  test.equal(Q.isPromiseLike(kewLikeFunction), true, 'A pretend function promise is a promise-like')

  test.done()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.ncall" id="apidoc.element.kew.ncall">
        function <span class="apidocSignatureSpan">kew.</span>ncall
        <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ncall(fn, scope, var_args) {
  return bindPromise.apply(null, arguments)()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function (result) {
  console.log('someFn(' + arg1 + ', ' + arg2 + ') = ' + result)
})
```

You can also use ``Q.fcall()`` with functions that return promises.

### `.<span class="apidocCodeKeywordSpan">ncall</span>()` and `.nfcall()` for Node.js callbacks

``Q.nfcall()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(fs.writeFile, '/tmp/myFile', 'content')
.then(function () {
  console.log('File written successfully')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.nfcall" id="apidoc.element.kew.nfcall">
        function <span class="apidocSignatureSpan">kew.</span>nfcall
        <span class="apidocSignatureSpan">(fn, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nfcall(fn, var_args) {
  // Insert an undefined argument for scope and let bindPromise() do the work.
  var args = Array.prototype.slice.call(arguments, 0)
  args.splice(1, 0, undefined)
  return ncall.apply(undefined, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function (result) {
  console.log('someFn(' + arg1 + ', ' + arg2 + ') = ' + result)
})
```

You can also use ``Q.fcall()`` with functions that return promises.

### `.ncall()` and `.<span class="apidocCodeKeywordSpan">nfcall</span>()` for Node.js callbacks

``Q.nfcall()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(fs.writeFile, '/tmp/myFile', 'content')
.then(function () {
  console.log('File written successfully')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.reject" id="apidoc.element.kew.reject">
        function <span class="apidocSignatureSpan">kew.</span>reject
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reject(e) {
  var promise = new Promise()
  promise.reject(e)
  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Object|undefined} scope
* @param {Array} args
*/
function nextTickCallback (defer, callback, scope, args) {
 try {
   defer.resolve(callback.apply(scope, args))
 } catch (thrown) {
   defer.<span class="apidocCodeKeywordSpan">reject</span>(thrown)
 }
}

/**
* Used for accessing the nextTick function from outside the kew module.
*
* @return {Function}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.resolve" id="apidoc.element.kew.resolve">
        function <span class="apidocSignatureSpan">kew.</span>resolve
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(data) {
  var promise = new Promise()
  promise.resolve(data)
  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Promise} defer
* @param {Function} callback
* @param {Object|undefined} scope
* @param {Array} args
*/
function nextTickCallback (defer, callback, scope, args) {
 try {
   defer.<span class="apidocCodeKeywordSpan">resolve</span>(callback.apply(scope, args))
 } catch (thrown) {
   defer.reject(thrown)
 }
}

/**
* Used for accessing the nextTick function from outside the kew module.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.setNextTickFunction" id="apidoc.element.kew.setNextTickFunction">
        function <span class="apidocSignatureSpan">kew.</span>setNextTickFunction
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setNextTickFunction(fn) {
  nextTick = fn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function synchronous (callback) {
callback()
}

var asynchronous = Q.getNextTickFunction()

exports.testAsynchronousSynchronous = function (test) {
Q.<span class="apidocCodeKeywordSpan">setNextTickFunction</span>(synchronous)

var number = 5

Q.resolve(true).then(function () {
  number = 6
})
test.equals(number, 6, 'Q should resolve synchronously')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.spread" id="apidoc.element.kew.spread">
        function <span class="apidocSignatureSpan">kew.</span>spread
        <span class="apidocSignatureSpan">(array, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spread(array, fn) {
  resolve(array).spread(fn)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Takes an array of results and spreads them to the arguments of a function.
* @param {!Array} array
* @param {!Function} fn
*/
function spread(array, fn) {
 resolve(array).<span class="apidocCodeKeywordSpan">spread</span>(fn)
}

/**
* Create a new Promise which looks like a deferred
*
* @return {!Promise}
*/
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise" id="apidoc.module.kew.Promise">module kew.Promise</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.Promise" id="apidoc.element.kew.Promise.Promise">
        function <span class="apidocSignatureSpan">kew.</span>Promise
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(onSuccess, onFail) {
  this.promise = this
  this._isPromise = true
  this._successFn = onSuccess
  this._failFn = onFail
  this._scope = this
  this._boundArgs = null
  this._hasContext = false
  this._nextContext = undefined
  this._currentContext = undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype" id="apidoc.module.kew.Promise.prototype">module kew.Promise.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._chainPromise" id="apidoc.element.kew.Promise.prototype._chainPromise">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_chainPromise
        <span class="apidocSignatureSpan">(promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chainPromise = function (promise) {
  var i
  if (this._hasContext) promise._useContext(this._nextContext)

  if (this._child) {
    this._child._chainPromise(promise)
  } else if (this._hasData) {
    promise._withInput(this._data)
  } else if (this._error) {
    // We can't rely on _withError() because it's called on the chained promises
    // and we need to use the source's _errorHandled state
    this._handleError()
    promise._withError(this._error)
  } else if (!this._promises) {
    this._promises = [promise]
  } else {
    this._promises.push(promise)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this._error || this._hasData) throw new Error("Unable to resolve or reject the same promise twice")

  var i
  if (data &amp;&amp; isPromise(data)) {
this._child = data
if (this._promises) {
  for (i = 0; i &lt; this._promises.length; i += 1) {
    data.<span class="apidocCodeKeywordSpan">_chainPromise</span>(this._promises[i])
  }
  delete this._promises
}

if (this._onComplete) {
  for (i = 0; i &lt; this._onComplete.length; i+= 1) {
    data.fin(this._onComplete[i])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._end" id="apidoc.element.kew.Promise.prototype._end">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_end = function () {
  if (this._error) {
    this._handleError()
    throw this._error
  }
  this._ended = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Mark this promise as "ended". If the promise is rejected, this will throw an
* error in whatever scope it happens to be in
*
* @return {!Promise.&lt;T&gt;} returns the current promise
* @deprecated Prefer done(), because it's consistent with Q.
*/
Promise.prototype.end = function () {
 this.<span class="apidocCodeKeywordSpan">_end</span>()
 return this
}


/**
* Mark this promise as "ended".
* @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._handleError" id="apidoc.element.kew.Promise.prototype._handleError">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_handleError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleError = function () {
  if (!this._errorHandled) {
    stats.errorsHandled++
    this._errorHandled = true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this._error || this._hasData) throw new Error("Unable to resolve or reject the same promise twice")

var i
this._error = e
stats.errorsEmitted++

if (this._ended) {
  this.<span class="apidocCodeKeywordSpan">_handleError</span>()
  process.nextTick(function onPromiseThrow() {
    throw e
  })
}

if (this._onComplete) {
  for (i = 0; i &lt; this._onComplete.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._nextTick" id="apidoc.element.kew.Promise.prototype._nextTick">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_nextTick
        <span class="apidocSignatureSpan">(fn, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_nextTick = function (fn, args) {
  if (this._boundArgs) {
    args = this._boundArgs.concat(args)
  }
  nextTick(nextTickCallback.bind(null, this, fn, this._scope, args))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Attempt to resolve this promise with the specified input
 *
 * @param {*} data the input
 */
Promise.prototype._withInput = function (data) {
  if (this._successFn) {
    this.<span class="apidocCodeKeywordSpan">_nextTick</span>(this._successFn, [data, this._currentContext])
  } else {
    this.resolve(data)
  }

  // context is no longer needed
  delete this._currentContext
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._useContext" id="apidoc.element.kew.Promise.prototype._useContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_useContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_useContext = function (context) {
  this._nextContext = this._currentContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      for (i = 0; i &lt; this._onComplete.length; i++) {
        this._onComplete[i]()
      }
    }

    if (this._promises) {
      for (i = 0; i &lt; this._promises.length; i += 1) {
        this._promises[i].<span class="apidocCodeKeywordSpan">_useContext</span>(this._nextContext)
        this._promises[i]._withInput(data)
      }
      delete this._promises
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withError" id="apidoc.element.kew.Promise.prototype._withError">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withError
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withError = function (e) {
  if (this._failFn) {
    this._nextTick(this._failFn, [e, this._currentContext])
  } else {
    this.reject(e)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
 }

 if (this._promises) {
   this._handleError()
   for (i = 0; i &lt; this._promises.length; i += 1) {
     this._promises[i]._useContext(this._nextContext)
     this._promises[i].<span class="apidocCodeKeywordSpan">_withError</span>(e)
   }
   delete this._promises
 }
}

/**
* Provide a callback to be called whenever this promise successfully
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withInput" id="apidoc.element.kew.Promise.prototype._withInput">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withInput
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withInput = function (data) {
  if (this._successFn) {
    this._nextTick(this._successFn, [data, this._currentContext])
  } else {
    this.resolve(data)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._onComplete[i]()
      }
    }

    if (this._promises) {
      for (i = 0; i &lt; this._promises.length; i += 1) {
        this._promises[i]._useContext(this._nextContext)
        this._promises[i].<span class="apidocCodeKeywordSpan">_withInput</span>(data)
      }
      delete this._promises
    }
  }
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.clearContext" id="apidoc.element.kew.Promise.prototype.clearContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>clearContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearContext = function () {
  this._hasContext = false
  this._nextContext = undefined
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	  	return Q.delay(500)
	  })
	  .setContext({id: 2})
	  .then(function (val, context) {
	  	test.equal(context.id, 2, 'Should return the second context')
	  	return Q.delay(500)
	  })
	  .<span class="apidocCodeKeywordSpan">clearContext</span>()
	  .then(function (val, context) {
	  	test.equal(typeof context, 'undefined', 'Should return an undefined context')
	  	return Q.delay(500)
	  })
	  .setContext({id: 3})
	  .fin(test.done)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.delay" id="apidoc.element.kew.Promise.prototype.delay">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>delay
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (ms) {
  return this.then(function (val) {
    return delay(val, ms)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Q.all(promises)
.fail(function (e) {
  console.log("Failed retrieving a url", e)
})
```

### `.<span class="apidocCodeKeywordSpan">delay</span>()` for future promises

If you need a little bit of delay (such as retrying a method call to a service that is "eventually consistent") before
 doing something else, ``Q.delay()`` is your friend:

```javascript
getUrlContent(url1)
.fail(function () {
// Retry again after 200 milisseconds
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.done" id="apidoc.element.kew.Promise.prototype.done">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>done
        <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">done = function (onSuccess, onFailure) {
  var self = this
  if (onSuccess || onFailure) {
    self = self.then(onSuccess, onFailure)
  }
  self._end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})

Q.all([promise2, promise4])
  .then(function (data) {
    test.equal(counter, 2, "fin() should have been called twice")
    test.equal(data[0], vals[0], "first fin() should return the first val")
    test.equal(data[1], vals[1], "second fin() should return the second val")
    test.<span class="apidocCodeKeywordSpan">done</span>()
  })
}

// test that fin() works with a synchronous reject
exports.testSynchronousFailAndFin = function (test) {
var errs = []
errs.push(new Error('nope 1'))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.end" id="apidoc.element.kew.Promise.prototype.end">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  this._end()
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .fail(function (e) {
    // the retry failed :(
    console.error("Retrieving the object '" + objId + "' failed")
  })
})
```

If you've reached the end of your promise chain, you may call `.<span class="apidocCodeKeywordSpan">end</span>()` which signifies
 that the promise chain is ended and any errors should be thrown in whatever scope the code is currently in:

```javascript
getObjectPromise
  // this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous
  .end()
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fail" id="apidoc.element.kew.Promise.prototype.fail">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fail
        <span class="apidocSignatureSpan">(onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fail = function (onFail) {
  return this.then(null, onFail)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getObjectFromDatabase(myObjectId, defer.makeNodeResolver())

// grab the output
defer.promise
  .then(function (obj) {
    // successfully retrieved the object
  })
  .<span class="apidocCodeKeywordSpan">fail</span>(function (e) {
    // failed retrieving the object
  })
```

### Handling successful results with `.then()`

When a promise is resolved, you may call the `.then()` method to retrieve the value of the promise:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.failBound" id="apidoc.element.kew.Promise.prototype.failBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>failBound
        <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failBound = function (onFail, scope, var_args) {
  var promise = new Promise(null, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &gt; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

examplePromise.then(null, errorCallback);
examplePromise.then(null, errorCallbackWithContext);
};


var thenBound = function () {
stringPromise().thenBound(callbackNeedsBind, null, 3).<span class="apidocCodeKeywordSpan">failBound</span>(callbackNeedsBind, null
, 3);
};

var examplePromise = function () {
var promise = new Promise(callback);
promise = new Promise(callbackWithContext);
promise = new Promise(null, errorCallback);
promise = new Promise(null, errorCallbackWithContext);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fin" id="apidoc.element.kew.Promise.prototype.fin">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fin
        <span class="apidocSignatureSpan">(onComplete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fin = function (onComplete) {
  if (this._hasData || this._error) {
    onComplete()
    return this
  }

  if (this._child) {
    this._child.fin(onComplete)
  } else {
    if (!this._onComplete) this._onComplete = [onComplete]
    else this._onComplete.push(onComplete)
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      data._chainPromise(this._promises[i])
    }
    delete this._promises
  }

  if (this._onComplete) {
    for (i = 0; i &lt; this._onComplete.length; i+= 1) {
      data.<span class="apidocCodeKeywordSpan">fin</span>(this._onComplete[i])
    }
    delete this._onComplete
  }
} else if (data &amp;&amp; isPromiseLike(data)) {
  data.then(
    function(data) { this.resolve(data) }.bind(this),
    function(err) { this.reject(err) }.bind(this)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.getContext" id="apidoc.element.kew.Promise.prototype.getContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function () {
  return this._nextContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.makeNodeResolver" id="apidoc.element.kew.Promise.prototype.makeNodeResolver">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>makeNodeResolver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeNodeResolver = function () {
  return resolver.bind(null, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {function(...)}: !Promise}
 */
function bindPromise(fn, scope, var_args) {
  var rootArgs = Array.prototype.slice.call(arguments, 2)
  return function onBoundPromise(var_args) {
    var defer = new Promise()
    try {
      fn.apply(scope, rootArgs.concat(Array.prototype.slice.call(arguments, 0), defer.<span class="apidocCodeKeywordSpan">makeNodeResolver
</span>()))
    } catch (e) {
      defer.reject(e)
    }
    return defer
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.reject" id="apidoc.element.kew.Promise.prototype.reject">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>reject
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (e) {
  if (this._error || this._hasData) throw new Error("Unable to resolve or reject the same promise twice")

  var i
  this._error = e
  stats.errorsEmitted++

  if (this._ended) {
    this._handleError()
    process.nextTick(function onPromiseThrow() {
      throw e
    })
  }

  if (this._onComplete) {
    for (i = 0; i &lt; this._onComplete.length; i++) {
      this._onComplete[i]()
    }
  }

  if (this._promises) {
    this._handleError()
    for (i = 0; i &lt; this._promises.length; i += 1) {
      this._promises[i]._useContext(this._nextContext)
      this._promises[i]._withError(e)
    }
    delete this._promises
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Object|undefined} scope
* @param {Array} args
*/
function nextTickCallback (defer, callback, scope, args) {
 try {
   defer.resolve(callback.apply(scope, args))
 } catch (thrown) {
   defer.<span class="apidocCodeKeywordSpan">reject</span>(thrown)
 }
}

/**
* Used for accessing the nextTick function from outside the kew module.
*
* @return {Function}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.resolve" id="apidoc.element.kew.Promise.prototype.resolve">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>resolve
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (data) {
  if (this._error || this._hasData) throw new Error("Unable to resolve or reject the same promise twice")

  var i
  if (data &amp;&amp; isPromise(data)) {
    this._child = data
    if (this._promises) {
      for (i = 0; i &lt; this._promises.length; i += 1) {
        data._chainPromise(this._promises[i])
      }
      delete this._promises
    }

    if (this._onComplete) {
      for (i = 0; i &lt; this._onComplete.length; i+= 1) {
        data.fin(this._onComplete[i])
      }
      delete this._onComplete
    }
  } else if (data &amp;&amp; isPromiseLike(data)) {
    data.then(
      function(data) { this.resolve(data) }.bind(this),
      function(err) { this.reject(err) }.bind(this)
    )
  } else {
    this._hasData = true
    this._data = data

    if (this._onComplete) {
      for (i = 0; i &lt; this._onComplete.length; i++) {
        this._onComplete[i]()
      }
    }

    if (this._promises) {
      for (i = 0; i &lt; this._promises.length; i += 1) {
        this._promises[i]._useContext(this._nextContext)
        this._promises[i]._withInput(data)
      }
      delete this._promises
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Promise} defer
* @param {Function} callback
* @param {Object|undefined} scope
* @param {Array} args
*/
function nextTickCallback (defer, callback, scope, args) {
 try {
   defer.<span class="apidocCodeKeywordSpan">resolve</span>(callback.apply(scope, args))
 } catch (thrown) {
   defer.reject(thrown)
 }
}

/**
* Used for accessing the nextTick function from outside the kew module.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.setContext" id="apidoc.element.kew.Promise.prototype.setContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>setContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setContext = function (context) {
  this._nextContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stringPromise = function () {
  return kew.resolve('string')
}

var exampleThen = function () {
  var examplePromise = new Promise();
  examplePromise.then(callback);
  examplePromise.<span class="apidocCodeKeywordSpan">setContext</span>([]);
  examplePromise.then(callbackWithContext);

  examplePromise.then(null, errorCallback);
  examplePromise.then(null, errorCallbackWithContext);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spread" id="apidoc.element.kew.Promise.prototype.spread">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spread
        <span class="apidocSignatureSpan">(onSuccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spread = function (onSuccess) {
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(null, array)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Takes an array of results and spreads them to the arguments of a function.
* @param {!Array} array
* @param {!Function} fn
*/
function spread(array, fn) {
 resolve(array).<span class="apidocCodeKeywordSpan">spread</span>(fn)
}

/**
* Create a new Promise which looks like a deferred
*
* @return {!Promise}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spreadBound" id="apidoc.element.kew.Promise.prototype.spreadBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spreadBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadBound = function (onSuccess, scope, var_args) {
  var args = Array.prototype.slice.call(arguments, 2)
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(scope, args.concat(array))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

exports.testSpreadBoundMethod = function (test) {
  Q.resolve(true)
      .then(function () {
        return [Q.resolve('a'), 'b']
      })
      .<span class="apidocCodeKeywordSpan">spreadBound</span>(function (c, a, b) {
        test.equal('scope', this.scope)
        test.equal('c', c)
        test.equal('a', a)
        test.equal('b', b)
        test.done()
      }, {scope: 'scope'}, 'c')
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.then" id="apidoc.element.kew.Promise.prototype.then">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>then
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (onSuccess, onFail) {
  var promise = new Promise(onSuccess, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this._onComplete) {
    for (i = 0; i &lt; this._onComplete.length; i+= 1) {
      data.fin(this._onComplete[i])
    }
    delete this._onComplete
  }
} else if (data &amp;&amp; isPromiseLike(data)) {
  data.<span class="apidocCodeKeywordSpan">then</span>(
    function(data) { this.resolve(data) }.bind(this),
    function(err) { this.reject(err) }.bind(this)
  )
} else {
  this._hasData = true
  this._data = data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.thenBound" id="apidoc.element.kew.Promise.prototype.thenBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>thenBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thenBound = function (onSuccess, scope, var_args) {
  var promise = new Promise(onSuccess)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &gt; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

examplePromise.then(null, errorCallback);
examplePromise.then(null, errorCallbackWithContext);
};


var thenBound = function () {
stringPromise().<span class="apidocCodeKeywordSpan">thenBound</span>(callbackNeedsBind, null, 3).failBound(callbackNeedsBind, null
, 3);
};

var examplePromise = function () {
var promise = new Promise(callback);
promise = new Promise(callbackWithContext);
promise = new Promise(null, errorCallback);
promise = new Promise(null, errorCallbackWithContext);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.timeout" id="apidoc.element.kew.Promise.prototype.timeout">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>timeout
        <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeout = function (timeoutMs, timeoutMsg) {
  var deferred = new Promise()
  var isTimeout = false

  var timeout = setTimeout(function() {
    deferred.reject(new Error(timeoutMsg || 'Promise timeout after ' + timeoutMs + ' ms.'))
    isTimeout = true
  }, timeoutMs)

  this.then(function (data) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.resolve(data)
    }
  },
  function (err) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.reject(err)
    }
  })

  return deferred.promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .then(function (data) {
    test.equals(0, data.length)
    test.done()
  })
}

exports.testTimeout = function(test) {
var promise = Q.delay(50).<span class="apidocCodeKeywordSpan">timeout</span>(45, 'Timeout message')
promise.then(function () {
  test.fail('The promise is supposed to be timeout')
})
.fail(function (e) {
  test.equals('Timeout message', e.message, 'The error message should be the one passed into timeout()')
})
.fin(test.done)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>