<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/Medium/kew"

    >kew (v0.7.0)</a>
</h1>
<h4>a lightweight promise library for node</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew">module kew</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise">
            function <span class="apidocSignatureSpan">kew.</span>Promise
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._chainPromise">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._chainPromise
            <span class="apidocSignatureSpan">(promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._end">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._handleError">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._handleError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._nextTick">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._nextTick
            <span class="apidocSignatureSpan">(fn, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._useContext">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._useContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withError">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._withError
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withInput">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._withInput
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.clearContext">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.clearContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.delay">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.delay
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.done">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.done
            <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.end">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fail">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.fail
            <span class="apidocSignatureSpan">(onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.failBound">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.failBound
            <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fin">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.fin
            <span class="apidocSignatureSpan">(onComplete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.getContext">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.makeNodeResolver">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.makeNodeResolver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.reject">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.reject
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.resolve">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.resolve
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.setContext">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.setContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spread">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.spread
            <span class="apidocSignatureSpan">(onSuccess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spreadBound">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.spreadBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.then">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.then
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.thenBound">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.thenBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.timeout">
            function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.timeout
            <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.all">
            function <span class="apidocSignatureSpan">kew.</span>all
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.allSettled">
            function <span class="apidocSignatureSpan">kew.</span>allSettled
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.bindPromise">
            function <span class="apidocSignatureSpan">kew.</span>bindPromise
            <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.defer">
            function <span class="apidocSignatureSpan">kew.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.delay">
            function <span class="apidocSignatureSpan">kew.</span>delay
            <span class="apidocSignatureSpan">(delayMsOrVal, opt_delayMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.fcall">
            function <span class="apidocSignatureSpan">kew.</span>fcall
            <span class="apidocSignatureSpan">(fn, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.getNextTickFunction">
            function <span class="apidocSignatureSpan">kew.</span>getNextTickFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.isPromise">
            function <span class="apidocSignatureSpan">kew.</span>isPromise
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.isPromiseLike">
            function <span class="apidocSignatureSpan">kew.</span>isPromiseLike
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.ncall">
            function <span class="apidocSignatureSpan">kew.</span>ncall
            <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.nfcall">
            function <span class="apidocSignatureSpan">kew.</span>nfcall
            <span class="apidocSignatureSpan">(fn, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.reject">
            function <span class="apidocSignatureSpan">kew.</span>reject
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.resolve">
            function <span class="apidocSignatureSpan">kew.</span>resolve
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.setNextTickFunction">
            function <span class="apidocSignatureSpan">kew.</span>setNextTickFunction
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.spread">
            function <span class="apidocSignatureSpan">kew.</span>spread
            <span class="apidocSignatureSpan">(array, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kew.</span>Promise.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kew.</span>stats</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise">module kew.Promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.Promise">
            function <span class="apidocSignatureSpan">kew.</span>Promise
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype">module kew.Promise.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._chainPromise">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_chainPromise
            <span class="apidocSignatureSpan">(promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._end">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._handleError">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_handleError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._nextTick">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_nextTick
            <span class="apidocSignatureSpan">(fn, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._useContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_useContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withError">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withError
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withInput">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withInput
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.clearContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>clearContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.delay">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>delay
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.done">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>done
            <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.end">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fail">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fail
            <span class="apidocSignatureSpan">(onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.failBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>failBound
            <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fin">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fin
            <span class="apidocSignatureSpan">(onComplete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.getContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.makeNodeResolver">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>makeNodeResolver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.reject">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>reject
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.resolve">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>resolve
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.setContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>setContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spread">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spread
            <span class="apidocSignatureSpan">(onSuccess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spreadBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spreadBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.then">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>then
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.thenBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>thenBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.timeout">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>timeout
            <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype._chainPromise">module kew.Promise.prototype._chainPromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._chainPromise._chainPromise">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_chainPromise
            <span class="apidocSignatureSpan">(promise)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype._end">module kew.Promise.prototype._end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._end._end">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype._handleError">module kew.Promise.prototype._handleError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._handleError._handleError">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_handleError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype._nextTick">module kew.Promise.prototype._nextTick</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._nextTick._nextTick">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_nextTick
            <span class="apidocSignatureSpan">(fn, args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype._useContext">module kew.Promise.prototype._useContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._useContext._useContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_useContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype._withError">module kew.Promise.prototype._withError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withError._withError">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withError
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype._withInput">module kew.Promise.prototype._withInput</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype._withInput._withInput">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withInput
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.clearContext">module kew.Promise.prototype.clearContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.clearContext.clearContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>clearContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.delay">module kew.Promise.prototype.delay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.delay.delay">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>delay
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.done">module kew.Promise.prototype.done</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.done.done">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>done
            <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.end">module kew.Promise.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.end.end">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.fail">module kew.Promise.prototype.fail</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fail.fail">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fail
            <span class="apidocSignatureSpan">(onFail)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.failBound">module kew.Promise.prototype.failBound</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.failBound.failBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>failBound
            <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.fin">module kew.Promise.prototype.fin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.fin.fin">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fin
            <span class="apidocSignatureSpan">(onComplete)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.getContext">module kew.Promise.prototype.getContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.getContext.getContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.makeNodeResolver">module kew.Promise.prototype.makeNodeResolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.makeNodeResolver.makeNodeResolver">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>makeNodeResolver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.reject">module kew.Promise.prototype.reject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.reject.reject">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>reject
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.resolve">module kew.Promise.prototype.resolve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.resolve.resolve">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>resolve
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.setContext">module kew.Promise.prototype.setContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.setContext.setContext">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>setContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.spread">module kew.Promise.prototype.spread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spread.spread">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spread
            <span class="apidocSignatureSpan">(onSuccess)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.spreadBound">module kew.Promise.prototype.spreadBound</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.spreadBound.spreadBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spreadBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.then">module kew.Promise.prototype.then</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.then.then">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>then
            <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.thenBound">module kew.Promise.prototype.thenBound</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.thenBound.thenBound">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>thenBound
            <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.Promise.prototype.timeout">module kew.Promise.prototype.timeout</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.Promise.prototype.timeout.timeout">
            function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>timeout
            <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.all">module kew.all</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.all.all">
            function <span class="apidocSignatureSpan">kew.</span>all
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.allSettled">module kew.allSettled</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.allSettled.allSettled">
            function <span class="apidocSignatureSpan">kew.</span>allSettled
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.bindPromise">module kew.bindPromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.bindPromise.bindPromise">
            function <span class="apidocSignatureSpan">kew.</span>bindPromise
            <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.defer">module kew.defer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.defer.defer">
            function <span class="apidocSignatureSpan">kew.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.delay">module kew.delay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.delay.delay">
            function <span class="apidocSignatureSpan">kew.</span>delay
            <span class="apidocSignatureSpan">(delayMsOrVal, opt_delayMs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.fcall">module kew.fcall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.fcall.fcall">
            function <span class="apidocSignatureSpan">kew.</span>fcall
            <span class="apidocSignatureSpan">(fn, var_args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.getNextTickFunction">module kew.getNextTickFunction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.getNextTickFunction.getNextTickFunction">
            function <span class="apidocSignatureSpan">kew.</span>getNextTickFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.isPromise">module kew.isPromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.isPromise.isPromise">
            function <span class="apidocSignatureSpan">kew.</span>isPromise
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.isPromiseLike">module kew.isPromiseLike</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.isPromiseLike.isPromiseLike">
            function <span class="apidocSignatureSpan">kew.</span>isPromiseLike
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.ncall">module kew.ncall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.ncall.ncall">
            function <span class="apidocSignatureSpan">kew.</span>ncall
            <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.nfcall">module kew.nfcall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.nfcall.nfcall">
            function <span class="apidocSignatureSpan">kew.</span>nfcall
            <span class="apidocSignatureSpan">(fn, var_args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.reject">module kew.reject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.reject.reject">
            function <span class="apidocSignatureSpan">kew.</span>reject
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.resolve">module kew.resolve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.resolve.resolve">
            function <span class="apidocSignatureSpan">kew.</span>resolve
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.setNextTickFunction">module kew.setNextTickFunction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.setNextTickFunction.setNextTickFunction">
            function <span class="apidocSignatureSpan">kew.</span>setNextTickFunction
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kew.spread">module kew.spread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kew.spread.spread">
            function <span class="apidocSignatureSpan">kew.</span>spread
            <span class="apidocSignatureSpan">(array, fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew" id="apidoc.module.kew">module kew</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise" id="apidoc.element.kew.Promise">
        function <span class="apidocSignatureSpan">kew.</span>Promise
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(onSuccess, onFail) {
  this.promise = this
  this._isPromise = true
  this._successFn = onSuccess
  this._failFn = onFail
  this._scope = this
  this._boundArgs = null
  this._hasContext = false
  this._nextContext = undefined
  this._currentContext = undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._chainPromise" id="apidoc.element.kew.Promise.prototype._chainPromise">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._chainPromise
        <span class="apidocSignatureSpan">(promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype._chainPromise = function (promise) {
  var i
  if (this._hasContext) promise._useContext(this._nextContext)

  if (this._child) {
    this._child._chainPromise(promise)
  } else if (this._hasData) {
    promise._withInput(this._data)
  } else if (this._error) {
    // We can&#x27;t rely on _withError() because it&#x27;s called on the chained promises
    // and we need to use the source&#x27;s _errorHandled state
    this._handleError()
    promise._withError(this._error)
  } else if (!this._promises) {
    this._promises = [promise]
  } else {
    this._promises.push(promise)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._end" id="apidoc.element.kew.Promise.prototype._end">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype._end = function () {
  if (this._error) {
    this._handleError()
    throw this._error
  }
  this._ended = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._handleError" id="apidoc.element.kew.Promise.prototype._handleError">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._handleError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype._handleError = function () {
  if (!this._errorHandled) {
    stats.errorsHandled++
    this._errorHandled = true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._nextTick" id="apidoc.element.kew.Promise.prototype._nextTick">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._nextTick
        <span class="apidocSignatureSpan">(fn, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype._nextTick = function (fn, args) {
  if (this._boundArgs) {
    args = this._boundArgs.concat(args)
  }
  nextTick(nextTickCallback.bind(null, this, fn, this._scope, args))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._useContext" id="apidoc.element.kew.Promise.prototype._useContext">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._useContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype._useContext = function (context) {
  this._nextContext = this._currentContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withError" id="apidoc.element.kew.Promise.prototype._withError">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._withError
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype._withError = function (e) {
  if (this._failFn) {
    this._nextTick(this._failFn, [e, this._currentContext])
  } else {
    this.reject(e)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withInput" id="apidoc.element.kew.Promise.prototype._withInput">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype._withInput
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype._withInput = function (data) {
  if (this._successFn) {
    this._nextTick(this._successFn, [data, this._currentContext])
  } else {
    this.resolve(data)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.clearContext" id="apidoc.element.kew.Promise.prototype.clearContext">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.clearContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.clearContext = function () {
  this._hasContext = false
  this._nextContext = undefined
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.delay" id="apidoc.element.kew.Promise.prototype.delay">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.delay
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.delay = function (ms) {
  return this.then(function (val) {
    return delay(val, ms)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.done" id="apidoc.element.kew.Promise.prototype.done">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.done
        <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.done = function (onSuccess, onFailure) {
  var self = this
  if (onSuccess || onFailure) {
    self = self.then(onSuccess, onFailure)
  }
  self._end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.end" id="apidoc.element.kew.Promise.prototype.end">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.end = function () {
  this._end()
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fail" id="apidoc.element.kew.Promise.prototype.fail">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.fail
        <span class="apidocSignatureSpan">(onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.fail = function (onFail) {
  return this.then(null, onFail)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.failBound" id="apidoc.element.kew.Promise.prototype.failBound">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.failBound
        <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.failBound = function (onFail, scope, var_args) {
  var promise = new Promise(null, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &#x3e; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fin" id="apidoc.element.kew.Promise.prototype.fin">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.fin
        <span class="apidocSignatureSpan">(onComplete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.fin = function (onComplete) {
  if (this._hasData || this._error) {
    onComplete()
    return this
  }

  if (this._child) {
    this._child.fin(onComplete)
  } else {
    if (!this._onComplete) this._onComplete = [onComplete]
    else this._onComplete.push(onComplete)
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.getContext" id="apidoc.element.kew.Promise.prototype.getContext">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.getContext = function () {
  return this._nextContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.makeNodeResolver" id="apidoc.element.kew.Promise.prototype.makeNodeResolver">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.makeNodeResolver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.makeNodeResolver = function () {
  return resolver.bind(null, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.reject" id="apidoc.element.kew.Promise.prototype.reject">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.reject
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.reject = function (e) {
  if (this._error || this._hasData) throw new Error(&#x22;Unable to resolve or reject the same promise twice&#x22;)

  var i
  this._error = e
  stats.errorsEmitted++

  if (this._ended) {
    this._handleError()
    process.nextTick(function onPromiseThrow() {
      throw e
    })
  }

  if (this._onComplete) {
    for (i = 0; i &#x3c; this._onComplete.length; i++) {
      this._onComplete[i]()
    }
  }

  if (this._promises) {
    this._handleError()
    for (i = 0; i &#x3c; this._promises.length; i += 1) {
      this._promises[i]._useContext(this._nextContext)
      this._promises[i]._withError(e)
    }
    delete this._promises
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.resolve" id="apidoc.element.kew.Promise.prototype.resolve">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.resolve
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.resolve = function (data) {
  if (this._error || this._hasData) throw new Error(&#x22;Unable to resolve or reject the same promise twice&#x22;)

  var i
  if (data &#x26;&#x26; isPromise(data)) {
    this._child = data
    if (this._promises) {
      for (i = 0; i &#x3c; this._promises.length; i += 1) {
        data._chainPromise(this._promises[i])
      }
      delete this._promises
    }

    if (this._onComplete) {
      for (i = 0; i &#x3c; this._onComplete.length; i+= 1) {
        data.fin(this._onComplete[i])
      }
      delete this._onComplete
    }
  } else if (data &#x26;&#x26; isPromiseLike(data)) {
    data.then(
      function(data) { this.resolve(data) }.bind(this),
      function(err) { this.reject(err) }.bind(this)
    )
  } else {
    this._hasData = true
    this._data = data

    if (this._onComplete) {
      for (i = 0; i &#x3c; this._onComplete.length; i++) {
        this._onComplete[i]()
      }
    }

    if (this._promises) {
      for (i = 0; i &#x3c; this._promises.length; i += 1) {
        this._promises[i]._useContext(this._nextContext)
        this._promises[i]._withInput(data)
      }
      delete this._promises
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.setContext" id="apidoc.element.kew.Promise.prototype.setContext">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.setContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.setContext = function (context) {
  this._nextContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spread" id="apidoc.element.kew.Promise.prototype.spread">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.spread
        <span class="apidocSignatureSpan">(onSuccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.spread = function (onSuccess) {
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(null, array)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spreadBound" id="apidoc.element.kew.Promise.prototype.spreadBound">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.spreadBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.spreadBound = function (onSuccess, scope, var_args) {
  var args = Array.prototype.slice.call(arguments, 2)
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(scope, args.concat(array))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.then" id="apidoc.element.kew.Promise.prototype.then">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.then
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.then = function (onSuccess, onFail) {
  var promise = new Promise(onSuccess, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.thenBound" id="apidoc.element.kew.Promise.prototype.thenBound">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.thenBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.thenBound = function (onSuccess, scope, var_args) {
  var promise = new Promise(onSuccess)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &#x3e; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.timeout" id="apidoc.element.kew.Promise.prototype.timeout">
        function <span class="apidocSignatureSpan">kew.</span>Promise.prototype.timeout
        <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise.prototype.timeout = function (timeoutMs, timeoutMsg) {
  var deferred = new Promise()
  var isTimeout = false

  var timeout = setTimeout(function() {
    deferred.reject(new Error(timeoutMsg || &#x27;Promise timeout after &#x27; + timeoutMs + &#x27; ms.&#x27;))
    isTimeout = true
  }, timeoutMs)

  this.then(function (data) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.resolve(data)
    }
  },
  function (err) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.reject(err)
    }
  })

  return deferred.promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.all" id="apidoc.element.kew.all">
        function <span class="apidocSignatureSpan">kew.</span>all
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(promises) {
  if (arguments.length != 1 || !Array.isArray(promises)) {
    promises = Array.prototype.slice.call(arguments, 0)
  }
  return allInternal(promises)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    db.close()
  })
```

Other utility methods
-------

### `.<span class="apidocCodeKeywordSpan">all</span>()` for many things

If you&#x27;re waiting for multiple promises to return, you may pass them (mixed in with literals if you desire) into `.all()` which
 will create a promise that resolves successfully with an array of the results of the promises:

```javascript
var promises = []
promises.push(getUrlContent(url1))
promises.push(getUrlContent(url2))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.allSettled" id="apidoc.element.kew.allSettled">
        function <span class="apidocSignatureSpan">kew.</span>allSettled
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allSettled(promises) {
  if (!Array.isArray(promises)) {
    throw Error(&#x27;The input to &#x22;allSettled()&#x22; should be an array of Promise or values&#x27;)
  }
  if (!promises.length) return resolve([])

  var outputs = []
  var promise = new Promise()
  var counter = promises.length

  for (var i = 0; i &#x3c; promises.length; i += 1) {
    if (!promises[i] || !isPromiseLike(promises[i])) {
      replaceElFulfilled(outputs, i, promises[i])
      if ((--counter) === 0) promise.resolve(outputs)
    } else {
      promises[i]
        .then(replaceElFulfilled.bind(null, outputs, i), replaceElRejected.bind(null, outputs, i))
        .then(function () {
          if ((--counter) === 0) promise.resolve(outputs)
        })
    }
  }

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.bindPromise" id="apidoc.element.kew.bindPromise">
        function <span class="apidocSignatureSpan">kew.</span>bindPromise
        <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bindPromise(fn, scope, var_args) {
  var rootArgs = Array.prototype.slice.call(arguments, 2)
  return function onBoundPromise(var_args) {
    var defer = new Promise()
    try {
      fn.apply(scope, rootArgs.concat(Array.prototype.slice.call(arguments, 0), defer.makeNodeResolver()))
    } catch (e) {
      defer.reject(e)
    }
    return defer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.defer" id="apidoc.element.kew.defer">
        function <span class="apidocSignatureSpan">kew.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer() {
  return new Promise()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var failPromise = Q.reject(err)
```

In addition, you can create deferreds which can be used if you need to create a promise but resolve it later:

```javascript
// create the deferreds
var successDefer = Q.<span class="apidocCodeKeywordSpan">defer</span>()
var failDefer = Q.defer()

// resolve or reject the defers in 1 second
setTimeout(function () {
  successDefer.resolve(&#x22;ok&#x22;)
  failDefer.reject(new Error(&#x22;this failed&#x22;))
}, 1000)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.delay" id="apidoc.element.kew.delay">
        function <span class="apidocSignatureSpan">kew.</span>delay
        <span class="apidocSignatureSpan">(delayMsOrVal, opt_delayMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delay(delayMsOrVal, opt_delayMs) {
  var returnVal = undefined
  var delayMs = delayMsOrVal
  if (typeof opt_delayMs != &#x27;undefined&#x27;) {
    delayMs = opt_delayMs
    returnVal = delayMsOrVal
  }

  if (typeof delayMs != &#x27;number&#x27;) {
    throw new Error(&#x27;Bad delay value &#x27; + delayMs)
  }

  var defer = new Promise()
  setTimeout(function onDelay() {
    defer.resolve(returnVal)
  }, delayMs)
  return defer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Q.all(promises)
.fail(function (e) {
  console.log(&#x22;Failed retrieving a url&#x22;, e)
})
```

### `.<span class="apidocCodeKeywordSpan">delay</span>()` for future promises

If you need a little bit of delay (such as retrying a method call to a service that is &#x22;eventually consistent&#x22;) before
 doing something else, ``Q.delay()`` is your friend:

```javascript
getUrlContent(url1)
.fail(function () {
// Retry again after 200 milisseconds
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.fcall" id="apidoc.element.kew.fcall">
        function <span class="apidocSignatureSpan">kew.</span>fcall
        <span class="apidocSignatureSpan">(fn, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fcall(fn, var_args) {
  var rootArgs = Array.prototype.slice.call(arguments, 1)
  var defer = new Promise()
  nextTick(nextTickCallback.bind(null, defer, fn, undefined, rootArgs))
  return defer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
Q.delay(obj, 20).then(function (result) {
  console.log(result) // logs `obj` after 20ms
})
```

### `.<span class="apidocCodeKeywordSpan">fcall</span>()` for delaying a function invocation until the next tick:
```javascript
// Assume someFn() is a synchronous 2 argument function you want to delay.
Q.fcall(someFn, arg1, arg2)
  .then(function (result) {
    console.log(&#x27;someFn(&#x27; + arg1 + &#x27;, &#x27; + arg2 + &#x27;) = &#x27; + result)
  })
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.getNextTickFunction" id="apidoc.element.kew.getNextTickFunction">
        function <span class="apidocSignatureSpan">kew.</span>getNextTickFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNextTickFunction() {
  return nextTick
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.isPromise" id="apidoc.element.kew.isPromise">
        function <span class="apidocSignatureSpan">kew.</span>isPromise
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromise(obj) {
  return !!obj._isPromise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.isPromiseLike" id="apidoc.element.kew.isPromiseLike">
        function <span class="apidocSignatureSpan">kew.</span>isPromiseLike
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromiseLike(obj) {
  return (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &#x26;&#x26;
    typeof obj.then === &#x27;function&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.ncall" id="apidoc.element.kew.ncall">
        function <span class="apidocSignatureSpan">kew.</span>ncall
        <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ncall(fn, scope, var_args) {
  return bindPromise.apply(null, arguments)()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function (result) {
  console.log(&#x27;someFn(&#x27; + arg1 + &#x27;, &#x27; + arg2 + &#x27;) = &#x27; + result)
})
```

You can also use ``Q.fcall()`` with functions that return promises.

### `.<span class="apidocCodeKeywordSpan">ncall</span>()` and `.nfcall()` for Node.js callbacks

``Q.nfcall()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(fs.writeFile, &#x27;/tmp/myFile&#x27;, &#x27;content&#x27;)
.then(function () {
  console.log(&#x27;File written successfully&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.nfcall" id="apidoc.element.kew.nfcall">
        function <span class="apidocSignatureSpan">kew.</span>nfcall
        <span class="apidocSignatureSpan">(fn, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nfcall(fn, var_args) {
  // Insert an undefined argument for scope and let bindPromise() do the work.
  var args = Array.prototype.slice.call(arguments, 0)
  args.splice(1, 0, undefined)
  return ncall.apply(undefined, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function (result) {
  console.log(&#x27;someFn(&#x27; + arg1 + &#x27;, &#x27; + arg2 + &#x27;) = &#x27; + result)
})
```

You can also use ``Q.fcall()`` with functions that return promises.

### `.ncall()` and `.<span class="apidocCodeKeywordSpan">nfcall</span>()` for Node.js callbacks

``Q.nfcall()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(fs.writeFile, &#x27;/tmp/myFile&#x27;, &#x27;content&#x27;)
.then(function () {
  console.log(&#x27;File written successfully&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.reject" id="apidoc.element.kew.reject">
        function <span class="apidocSignatureSpan">kew.</span>reject
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reject(e) {
  var promise = new Promise()
  promise.reject(e)
  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.resolve() or Q.<span class
="apidocCodeKeywordSpan">reject</span>()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.resolve" id="apidoc.element.kew.resolve">
        function <span class="apidocSignatureSpan">kew.</span>resolve
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(data) {
  var promise = new Promise()
  promise.resolve(data)
  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.<span class="apidocCodeKeywordSpan
">resolve</span>() or Q.reject()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.setNextTickFunction" id="apidoc.element.kew.setNextTickFunction">
        function <span class="apidocSignatureSpan">kew.</span>setNextTickFunction
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setNextTickFunction(fn) {
  nextTick = fn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.spread" id="apidoc.element.kew.spread">
        function <span class="apidocSignatureSpan">kew.</span>spread
        <span class="apidocSignatureSpan">(array, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spread(array, fn) {
  resolve(array).spread(fn)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
Q.ncall(redis.del, redis, &#x27;my-key&#x27;)
  .then(function () { return true })
  .fail(function () { return false })
```


### `.<span class="apidocCodeKeywordSpan">spread</span>()` for arrays of promises

``()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(function () {
  return [&#x27;a&#x27;, Q.resolve(&#x27;b&#x27;)]
})
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise" id="apidoc.module.kew.Promise">module kew.Promise</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.Promise" id="apidoc.element.kew.Promise.Promise">
        function <span class="apidocSignatureSpan">kew.</span>Promise
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(onSuccess, onFail) {
  this.promise = this
  this._isPromise = true
  this._successFn = onSuccess
  this._failFn = onFail
  this._scope = this
  this._boundArgs = null
  this._hasContext = false
  this._nextContext = undefined
  this._currentContext = undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype" id="apidoc.module.kew.Promise.prototype">module kew.Promise.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._chainPromise" id="apidoc.element.kew.Promise.prototype._chainPromise">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_chainPromise
        <span class="apidocSignatureSpan">(promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chainPromise = function (promise) {
  var i
  if (this._hasContext) promise._useContext(this._nextContext)

  if (this._child) {
    this._child._chainPromise(promise)
  } else if (this._hasData) {
    promise._withInput(this._data)
  } else if (this._error) {
    // We can&#x27;t rely on _withError() because it&#x27;s called on the chained promises
    // and we need to use the source&#x27;s _errorHandled state
    this._handleError()
    promise._withError(this._error)
  } else if (!this._promises) {
    this._promises = [promise]
  } else {
    this._promises.push(promise)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._end" id="apidoc.element.kew.Promise.prototype._end">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_end = function () {
  if (this._error) {
    this._handleError()
    throw this._error
  }
  this._ended = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._handleError" id="apidoc.element.kew.Promise.prototype._handleError">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_handleError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleError = function () {
  if (!this._errorHandled) {
    stats.errorsHandled++
    this._errorHandled = true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._nextTick" id="apidoc.element.kew.Promise.prototype._nextTick">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_nextTick
        <span class="apidocSignatureSpan">(fn, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_nextTick = function (fn, args) {
  if (this._boundArgs) {
    args = this._boundArgs.concat(args)
  }
  nextTick(nextTickCallback.bind(null, this, fn, this._scope, args))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._useContext" id="apidoc.element.kew.Promise.prototype._useContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_useContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_useContext = function (context) {
  this._nextContext = this._currentContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withError" id="apidoc.element.kew.Promise.prototype._withError">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withError
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withError = function (e) {
  if (this._failFn) {
    this._nextTick(this._failFn, [e, this._currentContext])
  } else {
    this.reject(e)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withInput" id="apidoc.element.kew.Promise.prototype._withInput">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withInput
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withInput = function (data) {
  if (this._successFn) {
    this._nextTick(this._successFn, [data, this._currentContext])
  } else {
    this.resolve(data)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.clearContext" id="apidoc.element.kew.Promise.prototype.clearContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>clearContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearContext = function () {
  this._hasContext = false
  this._nextContext = undefined
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.delay" id="apidoc.element.kew.Promise.prototype.delay">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>delay
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (ms) {
  return this.then(function (val) {
    return delay(val, ms)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Q.all(promises)
.fail(function (e) {
  console.log(&#x22;Failed retrieving a url&#x22;, e)
})
```

### `.<span class="apidocCodeKeywordSpan">delay</span>()` for future promises

If you need a little bit of delay (such as retrying a method call to a service that is &#x22;eventually consistent&#x22;) before
 doing something else, ``Q.delay()`` is your friend:

```javascript
getUrlContent(url1)
.fail(function () {
// Retry again after 200 milisseconds
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.done" id="apidoc.element.kew.Promise.prototype.done">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>done
        <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">done = function (onSuccess, onFailure) {
  var self = this
  if (onSuccess || onFailure) {
    self = self.then(onSuccess, onFailure)
  }
  self._end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.end" id="apidoc.element.kew.Promise.prototype.end">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  this._end()
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .fail(function (e) {
    // the retry failed :(
    console.error(&#x22;Retrieving the object &#x27;&#x22; + objId + &#x22;&#x27; failed&#x22;)
  })
})
```

If you&#x27;ve reached the end of your promise chain, you may call `.<span class="apidocCodeKeywordSpan">end</span>()` which signifies
 that the promise chain is ended and any errors should be thrown in whatever scope the code is currently in:

```javascript
getObjectPromise
  // this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous
  .end()
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fail" id="apidoc.element.kew.Promise.prototype.fail">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fail
        <span class="apidocSignatureSpan">(onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fail = function (onFail) {
  return this.then(null, onFail)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getObjectFromDatabase(myObjectId, defer.makeNodeResolver())

// grab the output
defer.promise
  .then(function (obj) {
    // successfully retrieved the object
  })
  .<span class="apidocCodeKeywordSpan">fail</span>(function (e) {
    // failed retrieving the object
  })
```

### Handling successful results with `.then()`

When a promise is resolved, you may call the `.then()` method to retrieve the value of the promise:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.failBound" id="apidoc.element.kew.Promise.prototype.failBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>failBound
        <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failBound = function (onFail, scope, var_args) {
  var promise = new Promise(null, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &#x3e; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fin" id="apidoc.element.kew.Promise.prototype.fin">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fin
        <span class="apidocSignatureSpan">(onComplete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fin = function (onComplete) {
  if (this._hasData || this._error) {
    onComplete()
    return this
  }

  if (this._child) {
    this._child.fin(onComplete)
  } else {
    if (!this._onComplete) this._onComplete = [onComplete]
    else this._onComplete.push(onComplete)
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
getObjectPromise
  // this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous
  .end()
```

### `.<span class="apidocCodeKeywordSpan">fin</span>()` when things are finished

You may attach a handler to a promise which will be ran regardless of whether the promise was resolved or rejected (but will only
 run upon completion). This is useful in the cases where you may have set up resources to run a request and wish to tear them down
 afterwards. `.fin()` will return the promise it is called upon:

```javascript
var connection = db.connect()

var itemPromise = db.getItem(itemId)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.getContext" id="apidoc.element.kew.Promise.prototype.getContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function () {
  return this._nextContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.makeNodeResolver" id="apidoc.element.kew.Promise.prototype.makeNodeResolver">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>makeNodeResolver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeNodeResolver = function () {
  return resolver.bind(null, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you have a node-style callback (taking an **Error** as the first parameter and a response as the second), you can call the magic
 `makeNodeResolver()` function on a defer to allow the defer to handle the callbacks:

```javascript
// create the deferred
var defer = Q.defer()

// some node-style function
getObjectFromDatabase(myObjectId, defer.<span class="apidocCodeKeywordSpan">makeNodeResolver</span>())

// grab the output
defer.promise
.then(function (obj) {
  // successfully retrieved the object
})
.fail(function (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.reject" id="apidoc.element.kew.Promise.prototype.reject">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>reject
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (e) {
  if (this._error || this._hasData) throw new Error(&#x22;Unable to resolve or reject the same promise twice&#x22;)

  var i
  this._error = e
  stats.errorsEmitted++

  if (this._ended) {
    this._handleError()
    process.nextTick(function onPromiseThrow() {
      throw e
    })
  }

  if (this._onComplete) {
    for (i = 0; i &#x3c; this._onComplete.length; i++) {
      this._onComplete[i]()
    }
  }

  if (this._promises) {
    this._handleError()
    for (i = 0; i &#x3c; this._promises.length; i += 1) {
      this._promises[i]._useContext(this._nextContext)
      this._promises[i]._withError(e)
    }
    delete this._promises
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.resolve() or Q.<span class
="apidocCodeKeywordSpan">reject</span>()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.resolve" id="apidoc.element.kew.Promise.prototype.resolve">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>resolve
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (data) {
  if (this._error || this._hasData) throw new Error(&#x22;Unable to resolve or reject the same promise twice&#x22;)

  var i
  if (data &#x26;&#x26; isPromise(data)) {
    this._child = data
    if (this._promises) {
      for (i = 0; i &#x3c; this._promises.length; i += 1) {
        data._chainPromise(this._promises[i])
      }
      delete this._promises
    }

    if (this._onComplete) {
      for (i = 0; i &#x3c; this._onComplete.length; i+= 1) {
        data.fin(this._onComplete[i])
      }
      delete this._onComplete
    }
  } else if (data &#x26;&#x26; isPromiseLike(data)) {
    data.then(
      function(data) { this.resolve(data) }.bind(this),
      function(err) { this.reject(err) }.bind(this)
    )
  } else {
    this._hasData = true
    this._data = data

    if (this._onComplete) {
      for (i = 0; i &#x3c; this._onComplete.length; i++) {
        this._onComplete[i]()
      }
    }

    if (this._promises) {
      for (i = 0; i &#x3c; this._promises.length; i += 1) {
        this._promises[i]._useContext(this._nextContext)
        this._promises[i]._withInput(data)
      }
      delete this._promises
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.<span class="apidocCodeKeywordSpan
">resolve</span>() or Q.reject()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.setContext" id="apidoc.element.kew.Promise.prototype.setContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>setContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setContext = function (context) {
  this._nextContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spread" id="apidoc.element.kew.Promise.prototype.spread">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spread
        <span class="apidocSignatureSpan">(onSuccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spread = function (onSuccess) {
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(null, array)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
Q.ncall(redis.del, redis, &#x27;my-key&#x27;)
  .then(function () { return true })
  .fail(function () { return false })
```


### `.<span class="apidocCodeKeywordSpan">spread</span>()` for arrays of promises

``()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(function () {
  return [&#x27;a&#x27;, Q.resolve(&#x27;b&#x27;)]
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spreadBound" id="apidoc.element.kew.Promise.prototype.spreadBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spreadBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadBound = function (onSuccess, scope, var_args) {
  var args = Array.prototype.slice.call(arguments, 2)
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(scope, args.concat(array))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.then" id="apidoc.element.kew.Promise.prototype.then">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>then
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (onSuccess, onFail) {
  var promise = new Promise(onSuccess, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
At its core, a *Promise* is a promise to return a value at some point in the future. A *Promise* represents a value that will be
 (or may return an error if something goes wrong). *Promises* heavily reduce the complexity of asynchronous coding in node.js-like
 environments. Example:

```javascript
// assuming the getUrlContent() function exists and retrieves the content of a url
var htmlPromise = getUrlContent(myUrl)

// we can then filter that through an http parser (our imaginary parseHtml() function) asynchronously (or maybe synchronously, who
 knows)
var tagsPromise = htmlPromise.<span class="apidocCodeKeywordSpan">then</span>(parseHtml)

// and then filter it through another function (getLinks()) which retrieves only the link tags
var linksPromise = tagsPromise.then(getLinks)

// and then parses the actual urls from the links (using parseUrlsFromLinks())
var urlsPromise = linksPromise.then(parseUrlsFromLinks)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.thenBound" id="apidoc.element.kew.Promise.prototype.thenBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>thenBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thenBound = function (onSuccess, scope, var_args) {
  var promise = new Promise(onSuccess)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &#x3e; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.timeout" id="apidoc.element.kew.Promise.prototype.timeout">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>timeout
        <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeout = function (timeoutMs, timeoutMsg) {
  var deferred = new Promise()
  var isTimeout = false

  var timeout = setTimeout(function() {
    deferred.reject(new Error(timeoutMsg || &#x27;Promise timeout after &#x27; + timeoutMs + &#x27; ms.&#x27;))
    isTimeout = true
  }, timeoutMs)

  this.then(function (data) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.resolve(data)
    }
  },
  function (err) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.reject(err)
    }
  })

  return deferred.promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype._chainPromise" id="apidoc.module.kew.Promise.prototype._chainPromise">module kew.Promise.prototype._chainPromise</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._chainPromise._chainPromise" id="apidoc.element.kew.Promise.prototype._chainPromise._chainPromise">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_chainPromise
        <span class="apidocSignatureSpan">(promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chainPromise = function (promise) {
  var i
  if (this._hasContext) promise._useContext(this._nextContext)

  if (this._child) {
    this._child._chainPromise(promise)
  } else if (this._hasData) {
    promise._withInput(this._data)
  } else if (this._error) {
    // We can&#x27;t rely on _withError() because it&#x27;s called on the chained promises
    // and we need to use the source&#x27;s _errorHandled state
    this._handleError()
    promise._withError(this._error)
  } else if (!this._promises) {
    this._promises = [promise]
  } else {
    this._promises.push(promise)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype._end" id="apidoc.module.kew.Promise.prototype._end">module kew.Promise.prototype._end</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._end._end" id="apidoc.element.kew.Promise.prototype._end._end">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_end = function () {
  if (this._error) {
    this._handleError()
    throw this._error
  }
  this._ended = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype._handleError" id="apidoc.module.kew.Promise.prototype._handleError">module kew.Promise.prototype._handleError</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._handleError._handleError" id="apidoc.element.kew.Promise.prototype._handleError._handleError">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_handleError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleError = function () {
  if (!this._errorHandled) {
    stats.errorsHandled++
    this._errorHandled = true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype._nextTick" id="apidoc.module.kew.Promise.prototype._nextTick">module kew.Promise.prototype._nextTick</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._nextTick._nextTick" id="apidoc.element.kew.Promise.prototype._nextTick._nextTick">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_nextTick
        <span class="apidocSignatureSpan">(fn, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_nextTick = function (fn, args) {
  if (this._boundArgs) {
    args = this._boundArgs.concat(args)
  }
  nextTick(nextTickCallback.bind(null, this, fn, this._scope, args))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype._useContext" id="apidoc.module.kew.Promise.prototype._useContext">module kew.Promise.prototype._useContext</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._useContext._useContext" id="apidoc.element.kew.Promise.prototype._useContext._useContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_useContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_useContext = function (context) {
  this._nextContext = this._currentContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype._withError" id="apidoc.module.kew.Promise.prototype._withError">module kew.Promise.prototype._withError</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withError._withError" id="apidoc.element.kew.Promise.prototype._withError._withError">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withError
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withError = function (e) {
  if (this._failFn) {
    this._nextTick(this._failFn, [e, this._currentContext])
  } else {
    this.reject(e)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype._withInput" id="apidoc.module.kew.Promise.prototype._withInput">module kew.Promise.prototype._withInput</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype._withInput._withInput" id="apidoc.element.kew.Promise.prototype._withInput._withInput">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>_withInput
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withInput = function (data) {
  if (this._successFn) {
    this._nextTick(this._successFn, [data, this._currentContext])
  } else {
    this.resolve(data)
  }

  // context is no longer needed
  delete this._currentContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.clearContext" id="apidoc.module.kew.Promise.prototype.clearContext">module kew.Promise.prototype.clearContext</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.clearContext.clearContext" id="apidoc.element.kew.Promise.prototype.clearContext.clearContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>clearContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearContext = function () {
  this._hasContext = false
  this._nextContext = undefined
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.delay" id="apidoc.module.kew.Promise.prototype.delay">module kew.Promise.prototype.delay</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.delay.delay" id="apidoc.element.kew.Promise.prototype.delay.delay">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>delay
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (ms) {
  return this.then(function (val) {
    return delay(val, ms)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Q.all(promises)
.fail(function (e) {
  console.log(&#x22;Failed retrieving a url&#x22;, e)
})
```

### `.<span class="apidocCodeKeywordSpan">delay</span>()` for future promises

If you need a little bit of delay (such as retrying a method call to a service that is &#x22;eventually consistent&#x22;) before
 doing something else, ``Q.delay()`` is your friend:

```javascript
getUrlContent(url1)
.fail(function () {
// Retry again after 200 milisseconds
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.done" id="apidoc.module.kew.Promise.prototype.done">module kew.Promise.prototype.done</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.done.done" id="apidoc.element.kew.Promise.prototype.done.done">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>done
        <span class="apidocSignatureSpan">(onSuccess, onFailure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">done = function (onSuccess, onFailure) {
  var self = this
  if (onSuccess || onFailure) {
    self = self.then(onSuccess, onFailure)
  }
  self._end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.end" id="apidoc.module.kew.Promise.prototype.end">module kew.Promise.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.end.end" id="apidoc.element.kew.Promise.prototype.end.end">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  this._end()
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .fail(function (e) {
    // the retry failed :(
    console.error(&#x22;Retrieving the object &#x27;&#x22; + objId + &#x22;&#x27; failed&#x22;)
  })
})
```

If you&#x27;ve reached the end of your promise chain, you may call `.<span class="apidocCodeKeywordSpan">end</span>()` which signifies
 that the promise chain is ended and any errors should be thrown in whatever scope the code is currently in:

```javascript
getObjectPromise
  // this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous
  .end()
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.fail" id="apidoc.module.kew.Promise.prototype.fail">module kew.Promise.prototype.fail</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fail.fail" id="apidoc.element.kew.Promise.prototype.fail.fail">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fail
        <span class="apidocSignatureSpan">(onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fail = function (onFail) {
  return this.then(null, onFail)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getObjectFromDatabase(myObjectId, defer.makeNodeResolver())

// grab the output
defer.promise
  .then(function (obj) {
    // successfully retrieved the object
  })
  .<span class="apidocCodeKeywordSpan">fail</span>(function (e) {
    // failed retrieving the object
  })
```

### Handling successful results with `.then()`

When a promise is resolved, you may call the `.then()` method to retrieve the value of the promise:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.failBound" id="apidoc.module.kew.Promise.prototype.failBound">module kew.Promise.prototype.failBound</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.failBound.failBound" id="apidoc.element.kew.Promise.prototype.failBound.failBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>failBound
        <span class="apidocSignatureSpan">(onFail, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">failBound = function (onFail, scope, var_args) {
  var promise = new Promise(null, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &#x3e; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.fin" id="apidoc.module.kew.Promise.prototype.fin">module kew.Promise.prototype.fin</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.fin.fin" id="apidoc.element.kew.Promise.prototype.fin.fin">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>fin
        <span class="apidocSignatureSpan">(onComplete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fin = function (onComplete) {
  if (this._hasData || this._error) {
    onComplete()
    return this
  }

  if (this._child) {
    this._child.fin(onComplete)
  } else {
    if (!this._onComplete) this._onComplete = [onComplete]
    else this._onComplete.push(onComplete)
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
getObjectPromise
  // this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous
  .end()
```

### `.<span class="apidocCodeKeywordSpan">fin</span>()` when things are finished

You may attach a handler to a promise which will be ran regardless of whether the promise was resolved or rejected (but will only
 run upon completion). This is useful in the cases where you may have set up resources to run a request and wish to tear them down
 afterwards. `.fin()` will return the promise it is called upon:

```javascript
var connection = db.connect()

var itemPromise = db.getItem(itemId)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.getContext" id="apidoc.module.kew.Promise.prototype.getContext">module kew.Promise.prototype.getContext</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.getContext.getContext" id="apidoc.element.kew.Promise.prototype.getContext.getContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function () {
  return this._nextContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.makeNodeResolver" id="apidoc.module.kew.Promise.prototype.makeNodeResolver">module kew.Promise.prototype.makeNodeResolver</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.makeNodeResolver.makeNodeResolver" id="apidoc.element.kew.Promise.prototype.makeNodeResolver.makeNodeResolver">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>makeNodeResolver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeNodeResolver = function () {
  return resolver.bind(null, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you have a node-style callback (taking an **Error** as the first parameter and a response as the second), you can call the magic
 `makeNodeResolver()` function on a defer to allow the defer to handle the callbacks:

```javascript
// create the deferred
var defer = Q.defer()

// some node-style function
getObjectFromDatabase(myObjectId, defer.<span class="apidocCodeKeywordSpan">makeNodeResolver</span>())

// grab the output
defer.promise
.then(function (obj) {
  // successfully retrieved the object
})
.fail(function (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.reject" id="apidoc.module.kew.Promise.prototype.reject">module kew.Promise.prototype.reject</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.reject.reject" id="apidoc.element.kew.Promise.prototype.reject.reject">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>reject
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (e) {
  if (this._error || this._hasData) throw new Error(&#x22;Unable to resolve or reject the same promise twice&#x22;)

  var i
  this._error = e
  stats.errorsEmitted++

  if (this._ended) {
    this._handleError()
    process.nextTick(function onPromiseThrow() {
      throw e
    })
  }

  if (this._onComplete) {
    for (i = 0; i &#x3c; this._onComplete.length; i++) {
      this._onComplete[i]()
    }
  }

  if (this._promises) {
    this._handleError()
    for (i = 0; i &#x3c; this._promises.length; i += 1) {
      this._promises[i]._useContext(this._nextContext)
      this._promises[i]._withError(e)
    }
    delete this._promises
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.resolve() or Q.<span class
="apidocCodeKeywordSpan">reject</span>()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.resolve" id="apidoc.module.kew.Promise.prototype.resolve">module kew.Promise.prototype.resolve</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.resolve.resolve" id="apidoc.element.kew.Promise.prototype.resolve.resolve">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>resolve
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (data) {
  if (this._error || this._hasData) throw new Error(&#x22;Unable to resolve or reject the same promise twice&#x22;)

  var i
  if (data &#x26;&#x26; isPromise(data)) {
    this._child = data
    if (this._promises) {
      for (i = 0; i &#x3c; this._promises.length; i += 1) {
        data._chainPromise(this._promises[i])
      }
      delete this._promises
    }

    if (this._onComplete) {
      for (i = 0; i &#x3c; this._onComplete.length; i+= 1) {
        data.fin(this._onComplete[i])
      }
      delete this._onComplete
    }
  } else if (data &#x26;&#x26; isPromiseLike(data)) {
    data.then(
      function(data) { this.resolve(data) }.bind(this),
      function(err) { this.reject(err) }.bind(this)
    )
  } else {
    this._hasData = true
    this._data = data

    if (this._onComplete) {
      for (i = 0; i &#x3c; this._onComplete.length; i++) {
        this._onComplete[i]()
      }
    }

    if (this._promises) {
      for (i = 0; i &#x3c; this._promises.length; i += 1) {
        this._promises[i]._useContext(this._nextContext)
        this._promises[i]._withInput(data)
      }
      delete this._promises
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.<span class="apidocCodeKeywordSpan
">resolve</span>() or Q.reject()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.setContext" id="apidoc.module.kew.Promise.prototype.setContext">module kew.Promise.prototype.setContext</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.setContext.setContext" id="apidoc.element.kew.Promise.prototype.setContext.setContext">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>setContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setContext = function (context) {
  this._nextContext = context
  this._hasContext = true
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.spread" id="apidoc.module.kew.Promise.prototype.spread">module kew.Promise.prototype.spread</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spread.spread" id="apidoc.element.kew.Promise.prototype.spread.spread">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spread
        <span class="apidocSignatureSpan">(onSuccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spread = function (onSuccess) {
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(null, array)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
Q.ncall(redis.del, redis, &#x27;my-key&#x27;)
  .then(function () { return true })
  .fail(function () { return false })
```


### `.<span class="apidocCodeKeywordSpan">spread</span>()` for arrays of promises

``()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(function () {
  return [&#x27;a&#x27;, Q.resolve(&#x27;b&#x27;)]
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.spreadBound" id="apidoc.module.kew.Promise.prototype.spreadBound">module kew.Promise.prototype.spreadBound</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.spreadBound.spreadBound" id="apidoc.element.kew.Promise.prototype.spreadBound.spreadBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>spreadBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadBound = function (onSuccess, scope, var_args) {
  var args = Array.prototype.slice.call(arguments, 2)
  return this.then(allInternal)
  .then(function (array) {
    return onSuccess.apply(scope, args.concat(array))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.then" id="apidoc.module.kew.Promise.prototype.then">module kew.Promise.prototype.then</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.then.then" id="apidoc.element.kew.Promise.prototype.then.then">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>then
        <span class="apidocSignatureSpan">(onSuccess, onFail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (onSuccess, onFail) {
  var promise = new Promise(onSuccess, onFail)
  if (this._nextContext) promise._useContext(this._nextContext)

  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
At its core, a *Promise* is a promise to return a value at some point in the future. A *Promise* represents a value that will be
 (or may return an error if something goes wrong). *Promises* heavily reduce the complexity of asynchronous coding in node.js-like
 environments. Example:

```javascript
// assuming the getUrlContent() function exists and retrieves the content of a url
var htmlPromise = getUrlContent(myUrl)

// we can then filter that through an http parser (our imaginary parseHtml() function) asynchronously (or maybe synchronously, who
 knows)
var tagsPromise = htmlPromise.<span class="apidocCodeKeywordSpan">then</span>(parseHtml)

// and then filter it through another function (getLinks()) which retrieves only the link tags
var linksPromise = tagsPromise.then(getLinks)

// and then parses the actual urls from the links (using parseUrlsFromLinks())
var urlsPromise = linksPromise.then(parseUrlsFromLinks)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.thenBound" id="apidoc.module.kew.Promise.prototype.thenBound">module kew.Promise.prototype.thenBound</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.thenBound.thenBound" id="apidoc.element.kew.Promise.prototype.thenBound.thenBound">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>thenBound
        <span class="apidocSignatureSpan">(onSuccess, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thenBound = function (onSuccess, scope, var_args) {
  var promise = new Promise(onSuccess)
  if (this._nextContext) promise._useContext(this._nextContext)

  promise._scope = scope
  if (arguments.length &#x3e; 2) {
    promise._boundArgs = Array.prototype.slice.call(arguments, 2)
  }

  // Chaining must happen after setting args and scope since it may fire callback.
  if (this._child) this._child._chainPromise(promise)
  else this._chainPromise(promise)

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.Promise.prototype.timeout" id="apidoc.module.kew.Promise.prototype.timeout">module kew.Promise.prototype.timeout</a></h1>


    <h2>
        <a href="#apidoc.element.kew.Promise.prototype.timeout.timeout" id="apidoc.element.kew.Promise.prototype.timeout.timeout">
        function <span class="apidocSignatureSpan">kew.Promise.prototype.</span>timeout
        <span class="apidocSignatureSpan">(timeoutMs, timeoutMsg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeout = function (timeoutMs, timeoutMsg) {
  var deferred = new Promise()
  var isTimeout = false

  var timeout = setTimeout(function() {
    deferred.reject(new Error(timeoutMsg || &#x27;Promise timeout after &#x27; + timeoutMs + &#x27; ms.&#x27;))
    isTimeout = true
  }, timeoutMs)

  this.then(function (data) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.resolve(data)
    }
  },
  function (err) {
    if (!isTimeout) {
      clearTimeout(timeout)
      deferred.reject(err)
    }
  })

  return deferred.promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.all" id="apidoc.module.kew.all">module kew.all</a></h1>


    <h2>
        <a href="#apidoc.element.kew.all.all" id="apidoc.element.kew.all.all">
        function <span class="apidocSignatureSpan">kew.</span>all
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(promises) {
  if (arguments.length != 1 || !Array.isArray(promises)) {
    promises = Array.prototype.slice.call(arguments, 0)
  }
  return allInternal(promises)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    db.close()
  })
```

Other utility methods
-------

### `.<span class="apidocCodeKeywordSpan">all</span>()` for many things

If you&#x27;re waiting for multiple promises to return, you may pass them (mixed in with literals if you desire) into `.all()` which
 will create a promise that resolves successfully with an array of the results of the promises:

```javascript
var promises = []
promises.push(getUrlContent(url1))
promises.push(getUrlContent(url2))
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.allSettled" id="apidoc.module.kew.allSettled">module kew.allSettled</a></h1>


    <h2>
        <a href="#apidoc.element.kew.allSettled.allSettled" id="apidoc.element.kew.allSettled.allSettled">
        function <span class="apidocSignatureSpan">kew.</span>allSettled
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allSettled(promises) {
  if (!Array.isArray(promises)) {
    throw Error(&#x27;The input to &#x22;allSettled()&#x22; should be an array of Promise or values&#x27;)
  }
  if (!promises.length) return resolve([])

  var outputs = []
  var promise = new Promise()
  var counter = promises.length

  for (var i = 0; i &#x3c; promises.length; i += 1) {
    if (!promises[i] || !isPromiseLike(promises[i])) {
      replaceElFulfilled(outputs, i, promises[i])
      if ((--counter) === 0) promise.resolve(outputs)
    } else {
      promises[i]
        .then(replaceElFulfilled.bind(null, outputs, i), replaceElRejected.bind(null, outputs, i))
        .then(function () {
          if ((--counter) === 0) promise.resolve(outputs)
        })
    }
  }

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.bindPromise" id="apidoc.module.kew.bindPromise">module kew.bindPromise</a></h1>


    <h2>
        <a href="#apidoc.element.kew.bindPromise.bindPromise" id="apidoc.element.kew.bindPromise.bindPromise">
        function <span class="apidocSignatureSpan">kew.</span>bindPromise
        <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bindPromise(fn, scope, var_args) {
  var rootArgs = Array.prototype.slice.call(arguments, 2)
  return function onBoundPromise(var_args) {
    var defer = new Promise()
    try {
      fn.apply(scope, rootArgs.concat(Array.prototype.slice.call(arguments, 0), defer.makeNodeResolver()))
    } catch (e) {
      defer.reject(e)
    }
    return defer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.defer" id="apidoc.module.kew.defer">module kew.defer</a></h1>


    <h2>
        <a href="#apidoc.element.kew.defer.defer" id="apidoc.element.kew.defer.defer">
        function <span class="apidocSignatureSpan">kew.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer() {
  return new Promise()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var failPromise = Q.reject(err)
```

In addition, you can create deferreds which can be used if you need to create a promise but resolve it later:

```javascript
// create the deferreds
var successDefer = Q.<span class="apidocCodeKeywordSpan">defer</span>()
var failDefer = Q.defer()

// resolve or reject the defers in 1 second
setTimeout(function () {
  successDefer.resolve(&#x22;ok&#x22;)
  failDefer.reject(new Error(&#x22;this failed&#x22;))
}, 1000)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.delay" id="apidoc.module.kew.delay">module kew.delay</a></h1>


    <h2>
        <a href="#apidoc.element.kew.delay.delay" id="apidoc.element.kew.delay.delay">
        function <span class="apidocSignatureSpan">kew.</span>delay
        <span class="apidocSignatureSpan">(delayMsOrVal, opt_delayMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delay(delayMsOrVal, opt_delayMs) {
  var returnVal = undefined
  var delayMs = delayMsOrVal
  if (typeof opt_delayMs != &#x27;undefined&#x27;) {
    delayMs = opt_delayMs
    returnVal = delayMsOrVal
  }

  if (typeof delayMs != &#x27;number&#x27;) {
    throw new Error(&#x27;Bad delay value &#x27; + delayMs)
  }

  var defer = new Promise()
  setTimeout(function onDelay() {
    defer.resolve(returnVal)
  }, delayMs)
  return defer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Q.all(promises)
.fail(function (e) {
  console.log(&#x22;Failed retrieving a url&#x22;, e)
})
```

### `.<span class="apidocCodeKeywordSpan">delay</span>()` for future promises

If you need a little bit of delay (such as retrying a method call to a service that is &#x22;eventually consistent&#x22;) before
 doing something else, ``Q.delay()`` is your friend:

```javascript
getUrlContent(url1)
.fail(function () {
// Retry again after 200 milisseconds
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.fcall" id="apidoc.module.kew.fcall">module kew.fcall</a></h1>


    <h2>
        <a href="#apidoc.element.kew.fcall.fcall" id="apidoc.element.kew.fcall.fcall">
        function <span class="apidocSignatureSpan">kew.</span>fcall
        <span class="apidocSignatureSpan">(fn, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fcall(fn, var_args) {
  var rootArgs = Array.prototype.slice.call(arguments, 1)
  var defer = new Promise()
  nextTick(nextTickCallback.bind(null, defer, fn, undefined, rootArgs))
  return defer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
Q.delay(obj, 20).then(function (result) {
  console.log(result) // logs `obj` after 20ms
})
```

### `.<span class="apidocCodeKeywordSpan">fcall</span>()` for delaying a function invocation until the next tick:
```javascript
// Assume someFn() is a synchronous 2 argument function you want to delay.
Q.fcall(someFn, arg1, arg2)
  .then(function (result) {
    console.log(&#x27;someFn(&#x27; + arg1 + &#x27;, &#x27; + arg2 + &#x27;) = &#x27; + result)
  })
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.getNextTickFunction" id="apidoc.module.kew.getNextTickFunction">module kew.getNextTickFunction</a></h1>


    <h2>
        <a href="#apidoc.element.kew.getNextTickFunction.getNextTickFunction" id="apidoc.element.kew.getNextTickFunction.getNextTickFunction">
        function <span class="apidocSignatureSpan">kew.</span>getNextTickFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNextTickFunction() {
  return nextTick
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.isPromise" id="apidoc.module.kew.isPromise">module kew.isPromise</a></h1>


    <h2>
        <a href="#apidoc.element.kew.isPromise.isPromise" id="apidoc.element.kew.isPromise.isPromise">
        function <span class="apidocSignatureSpan">kew.</span>isPromise
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromise(obj) {
  return !!obj._isPromise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.isPromiseLike" id="apidoc.module.kew.isPromiseLike">module kew.isPromiseLike</a></h1>


    <h2>
        <a href="#apidoc.element.kew.isPromiseLike.isPromiseLike" id="apidoc.element.kew.isPromiseLike.isPromiseLike">
        function <span class="apidocSignatureSpan">kew.</span>isPromiseLike
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromiseLike(obj) {
  return (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &#x26;&#x26;
    typeof obj.then === &#x27;function&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.ncall" id="apidoc.module.kew.ncall">module kew.ncall</a></h1>


    <h2>
        <a href="#apidoc.element.kew.ncall.ncall" id="apidoc.element.kew.ncall.ncall">
        function <span class="apidocSignatureSpan">kew.</span>ncall
        <span class="apidocSignatureSpan">(fn, scope, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ncall(fn, scope, var_args) {
  return bindPromise.apply(null, arguments)()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function (result) {
  console.log(&#x27;someFn(&#x27; + arg1 + &#x27;, &#x27; + arg2 + &#x27;) = &#x27; + result)
})
```

You can also use ``Q.fcall()`` with functions that return promises.

### `.<span class="apidocCodeKeywordSpan">ncall</span>()` and `.nfcall()` for Node.js callbacks

``Q.nfcall()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(fs.writeFile, &#x27;/tmp/myFile&#x27;, &#x27;content&#x27;)
.then(function () {
  console.log(&#x27;File written successfully&#x27;)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.nfcall" id="apidoc.module.kew.nfcall">module kew.nfcall</a></h1>


    <h2>
        <a href="#apidoc.element.kew.nfcall.nfcall" id="apidoc.element.kew.nfcall.nfcall">
        function <span class="apidocSignatureSpan">kew.</span>nfcall
        <span class="apidocSignatureSpan">(fn, var_args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nfcall(fn, var_args) {
  // Insert an undefined argument for scope and let bindPromise() do the work.
  var args = Array.prototype.slice.call(arguments, 0)
  args.splice(1, 0, undefined)
  return ncall.apply(undefined, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function (result) {
  console.log(&#x27;someFn(&#x27; + arg1 + &#x27;, &#x27; + arg2 + &#x27;) = &#x27; + result)
})
```

You can also use ``Q.fcall()`` with functions that return promises.

### `.ncall()` and `.<span class="apidocCodeKeywordSpan">nfcall</span>()` for Node.js callbacks

``Q.nfcall()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(fs.writeFile, &#x27;/tmp/myFile&#x27;, &#x27;content&#x27;)
.then(function () {
  console.log(&#x27;File written successfully&#x27;)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.reject" id="apidoc.module.kew.reject">module kew.reject</a></h1>


    <h2>
        <a href="#apidoc.element.kew.reject.reject" id="apidoc.element.kew.reject.reject">
        function <span class="apidocSignatureSpan">kew.</span>reject
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reject(e) {
  var promise = new Promise()
  promise.reject(e)
  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.resolve() or Q.<span class
="apidocCodeKeywordSpan">reject</span>()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.resolve" id="apidoc.module.kew.resolve">module kew.resolve</a></h1>


    <h2>
        <a href="#apidoc.element.kew.resolve.resolve" id="apidoc.element.kew.resolve.resolve">
        function <span class="apidocSignatureSpan">kew.</span>resolve
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(data) {
  var promise = new Promise()
  promise.resolve(data)
  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Q = require(&#x27;kew&#x27;)
```

### Convert a literal into a promise

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.<span class="apidocCodeKeywordSpan
">resolve</span>() or Q.reject()

```javascript
// create a promise which passes a value to the next then() call
var successPromise = Q.resolve(val)

// create a promise which throws an error to be caught by the next fail() call
var failPromise = Q.reject(err)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.setNextTickFunction" id="apidoc.module.kew.setNextTickFunction">module kew.setNextTickFunction</a></h1>


    <h2>
        <a href="#apidoc.element.kew.setNextTickFunction.setNextTickFunction" id="apidoc.element.kew.setNextTickFunction.setNextTickFunction">
        function <span class="apidocSignatureSpan">kew.</span>setNextTickFunction
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setNextTickFunction(fn) {
  nextTick = fn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kew.spread" id="apidoc.module.kew.spread">module kew.spread</a></h1>


    <h2>
        <a href="#apidoc.element.kew.spread.spread" id="apidoc.element.kew.spread.spread">
        function <span class="apidocSignatureSpan">kew.</span>spread
        <span class="apidocSignatureSpan">(array, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spread(array, fn) {
  resolve(array).spread(fn)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
Q.ncall(redis.del, redis, &#x27;my-key&#x27;)
  .then(function () { return true })
  .fail(function () { return false })
```


### `.<span class="apidocCodeKeywordSpan">spread</span>()` for arrays of promises

``()`` can be used to convert node-style callbacks into promises:

```javascript
Q.nfcall(function () {
  return [&#x27;a&#x27;, Q.resolve(&#x27;b&#x27;)]
})
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
